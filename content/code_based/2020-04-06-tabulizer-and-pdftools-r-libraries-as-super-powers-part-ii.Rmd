---
title: Tabulizer and pdftools R Libraries as Super-powers - Part II
author: David Lucey
date: '2020-04-06'
slug: tabulizer-and-pdftools-r-libraries-as-super-powers-part-ii
categories:
  - R
  - XBRL
  - Tabula
  - pdftools
tags:
  - pdf
  - rstats
  - ctdata
---

```{r 'set-up', message=FALSE, warning=FALSE, include=FALSE}

# Libraries
library(data.table)
library(stringr)
library(rlist)
library(tabulizer)
library(pdftools)
library(parallel)
library(DT)

```



# Introduction

When Redwall discovered pdftools, and its pdf_data function, which maps out every word on a pdf page by x-y coordinate, we thought that was interesting, but didn't really know how to use it. We also didn't have the regular expression skills, and were much more befuddled by the nested list structures than we are now. 

As for Tabulizer, it took about a year before rJava magically started working properly, but even then we it wasn't possible to consistently read a large number of tables of different sizes without cutting off fields in unexpected ways. Only in this Mass pdf scraping project have we realized that by combining these two packages, it becomes possible to access data with fairly reliable way from a large amount of varied pdf formats. 

Our Massachusset's municipal CAFR project provided a perfect opportunity to put all these pieces together. This blog post will consist of a step-by-step walk through which will hopefully help others avoid some of the pain that we experienced in getting to this point.

# Walk Through Plan

To begin with, we had to download the pdfs from the Center for Municipal Finance. We won't show the code to do this and all of this project here, but it can be found at [reason_pdf_parser.R](https://github.com/luceydav/pdf_cafr_parse/blob/master/reason_pdf_parser.R). In order to do this on the scale that we did for the project, we had to build large nested lists of all 150 Massachussett's CAFR pdfs. For now, we will just walk through a few key points on the Abington 2018 Statement of Net Position. The 2018 Abington CAFR used in this example is available for download [here](https://www.abingtonma.gov/home/pages/annual-town-reports).


```{r 'pdf-data', echo=TRUE, message=FALSE, warning=FALSE}

# Set up pdf and pdf_path to directory
dir <- "/Users/davidlucey/Desktop/David/Projects/mass_munis/data/pdf_cafr/"
city <- "abington"
pdf <- paste0(city, "_2018.pdf", collapse="")
pdf_path <- paste0(dir, pdf, collapse = "")

# Run pdf_data on Abington CAFR
abington <- pdftools::pdf_data(pdf_path)

# Name each page of list for page index in pdf
names(abington) <- 1:length(abington)

# Look at structure of 1st two elements of nested list
str(abington[1:2])
```

# PDF Tools pdf_data Functionality

The above is a list of data.frames containing metadata of the location of every word on every one of the 92 pages of the Abington 2018 CAFR. For example, the first page contains 16 and the second 266 words. But, we only need the key financial statements. So, it is possible to drop pages which don't have what we need. We know that page 16 has the Statement of net position. So we could search for that page like as shown for variable "sonp" below. We use the first 5 lines to look for the phrase "STATEMENT OF NET POSITION", but the "Proprietary Funds" and some other pages often have this phrase. Most of these other pages can be eliminated by choosing not to match the word "FUNDS".


```{r 'find-pdf-pages', echo=TRUE, message=FALSE, warning=FALSE}

# Convert elements to data.table
abington <- lapply(abington, setDT)

# Get index of Abington Statement of Net Position
sonp_index <- 
  which(
    unlist(
      lapply(abington, function(page){
        (str_detect(
          paste(
            # Reformat top 5 lines by y and look for match to "STATEMENT OF NET POSITION"
              page$text[
                page$y %in% head(unique(page$y), 5)
                ],
              collapse = " "
              ),
          "STATEMENT OF NET POSITION"
        ) & 
          # And requires both statements to be TRUE
          !str_detect(
            paste(
              page$text[
               # Reformat top 5 lines by y and look for non match to "FUNDS" 
                page$y %in% head(unique(page$y), 5)
                ],
              collapse = " "
              ),
            "FUNDS"
            )
        )
        }
        )
    )
    )
    
# Extract and View Statement of Net Position pdftools pdf_data  metadata
sonp <- abington[sonp_index][[1]]
sonp
```

Above is the text grid of Abington's Statement of Net Position as taken by pdftools' pdf_data function. Now we can begin to put together area parameters for Tabula. Using this grid, it is possible to extact the x-y coordinates of the four corners of the table, which allows a user to exactly specify area coordinates for Tabulizer. In our experience, this is important because Tabulizer's default "lattice" method for tabular data can be unpredictable cutting off fields unexpectedly. 


# Tabulizer Area Coordinates

Tabulizer specifies pages in blocks of 72 * inches, so a typical page would have dimensions of 612 x 720. All of of Massachusett's pdfs have a $ sign in the first and last rows, so that could be the top. In addition, all pages including financial statements have language referring users to the notes to the financial statements at the bottom. 

We give an example for Abington's Statement of Net Position below starting with the maximum "x" and "y", and determining the orientation. We then find the location of the date line at the top and walk down a little from there to set a table top. Typically, it is best to leave a little margin between the page header and the top of the table. The bottom of the table is set adding the height to the bottom line of the table, and left parameter is set by taking the smallest "x" coordinate and reducing by a little to avoid mistakes.  We leave an  larger margin for the right-most coordinate this is where a lot of errors can occur if the table algorithm tries to squish the table. 

In our experience, the most problems come with missetting the top and right parameters. Columns can be split in the middle into two columns, often at the far-rightmost, for example. In the end, we chose parameters of 93 (top), 24 (left), 681 (bottom) and 585 (right).

```{r 'calculate-tabulizer-area', echo=TRUE, message=FALSE, warning=FALSE}


 # Determine if page is verticle or horizontal
    x <- 8.5 * 72
    y <- 11 * 72
    max_x <- max(sonp$x)
    max_y <- max(sonp$y)
    orientation <- 
      ifelse(x < max_x, "horizontal", "verticle")
    
    # TOP
    
    # Keys on the first instance of the year "2018"
    table_top <-
      min(sonp$y[str_detect(sonp$text, "2018") & sonp$space==FALSE])
    # Find the height at in the table_top row
    height_top <- unique(sonp$height[sonp$y == table_top])
    # Add table_top and height_top to avoid slicing row
    top <- table_top + height_top 
    
    # BOTTOM
    
    # Table Bottom marked by last instance of character "$"
    table_bottom <-
      max(sonp$y[str_detect(sonp$text, "\\$")])
    # Height at bottom row of table 
    height_bottom <- unique(sonp$height[sonp$y == table_bottom])
    # Bottom of table
    bottom <- table_bottom + height_bottom
    
    # LEFT
    
    # Add some space to leftmost x coordinate to avoid slicing
    left <-     
      ifelse( min(sonp$x) - 30 > 0,
              min(sonp$x) - 30, 1 )
    
    # RIGHT
    
    # Find width at maximum "x" coordinate
    width_max_x <- max(sonp$width[sonp$x == max_x])
    # Add width at maximum "x" plus more space wether verticle or horizontal
    right <- 
      max_x + width_max_x + ifelse(orientation == "verticle", 30, 50)
    
    # FINAL AREA PARAMETER FOR TABULIZER AS INTEGER VECTOR
    # Note the specification as an integer vector
    a <- c(top, left, bottom, right)
    
    # Show coordinates 
    a
    
```

# Tabulizer extract_table Function

Below we run our parameters from above through Tabulizer. Note that the area parameter, itself an integer vector, is further wrapped as a list because not having this structure throws an error. In addition, please avoid the half day of wheel spinning we experienced by specifying guess as "F" to over-ride the default lattice, otherwise your area parameter is ignored with no warning. Also, we use the sonp_index integer to specify the page of the pdf. There are several options for output which all work as expected, but data.frame seems most natural.


```{r}

# Tabulizer extract_tables output is a list
abington_sonp <-
  extract_tables(
    pdf_path, 
    pages = sonp_index,
    area = list(a), 
    guess = F,
    output = "data.frame")

# Extract single element from list
abington_sonp <- abington_sonp[[1]]

```

# Clean up

The output is still in a raw form with colums sometimes determined by indentations and "x" values, such as the "$" signs. The numbers are in character form with commas, and need to be parsed into numeric. The biggest challenge is the column names which often include the first row of the full column name, and need to be rebuilt. This is not a small task and not what we were hoping to illustrate in this post, so we are just showing the output below. Please refer to our Github code for the a more complete explanation.


```{r 'clean-table', message=FALSE, warning=FALSE, include=FALSE}

clean_table <- function(page) {
  
  #page <- abington_sonp_dt
  
  # Convert to dt
  page <- setDT(page)
      
  # Select $ or all is.na columns and drop
  if(length(page) > 0) {
      drops <-
        sapply(page, function(col) which(any(str_detect(col, "^\\$$")) | all(is.na(col))))
      drops <- 
        which(sapply(drops, function(col) sum(col) > 0))
      page[ , (drops) := NULL] 
      }
      
  # Get names function to clean up names
  get_names <- function(page) {
    
    # Extract incomplete column names resulting from 
    # faulty tabula 
    names <- t(colnames(page))
    
    # Find empty rows at top to set to be combined with names
    empty  <-
      min(which(apply(page, function(row)
        ifelse(all(!str_detect(row[-1], "\\w")), 
               TRUE, 
               FALSE), 
        MARGIN = 1)))
    
    # Convert to matrix of first few rows and rbind with names
    page <- as.matrix(page)
    new <- 
      rbind(names, page)
    
    # Drop empty rows
    new <- new[1:empty,]
    
    # Build new names by pasting together rows by column
    names <- sapply(2:ncol(new), function(col) {
      name <- paste(new[, col], collapse = " ")
      name <- str_trim(str_remove(name, "X\\.?\\d?"))
      new[, col] <- name
    })
    names <- c("element", names)
  }
  
  #Run get names function 
  names(page) <- get_names(page)
  
  # Clean names to snake case
  page <- janitor::clean_names(page)
  
  # Drop empty rows
  page <- page[element != ""]
  
  # Clean and convert to numeric
  num <- names(page)[2:ncol(page)]
  page[, (num) := mclapply(.SD, function(col) {
    col[1] <- str_remove(col[1], "\\w*")
    col <- str_replace(col, "-", NA_character_)
    col <- str_remove(col, " ")
    col <- readr::parse_number(col, c("NA"))
    #col <- nafill(col, fill = 0L)
    col
  }), .SDcols=num]
  
  # Clean punctuation from rownames
  page[, element := str_remove(element, "\\W[\\s\\.\\$]*$")]
  
  # Return
  page
  
}

abington_final <- clean_table(abington_sonp)

names(abington_final) <- str_remove(names(abington_final), "primary_government_")
```


```{r 'final-dt', echo=TRUE, message=FALSE, warning=FALSE}

datatable(abington_final, 
  extensions = c('FixedColumns'),
  options = list(scrollY = TRUE,
                 pageLength=10),
              rownames = FALSE,
  caption = htmltools::tags$caption(
    style = 'caption-side: bottom; text-align: right;',
    '', htmltools::em('Source: Abington Mass Town Reports')
    )
  ) %>%
  formatStyle(columns = c(1:4),
              fontSize = '100%') %>%
  formatCurrency(
    columns = c(2:4),
    currency = "",
    interval = 3,
    mark = ",",
    digits = 0
  )

```

# Final Product

Though there is still work to be done, the final product of this post is shown below. Single elements could be extracted to form a database, or the output could be saved to csv. The headers such as ASSETS AAND LIABILITIES could be nested. The main point is that short of XBRL, the data has been set free from the PDF in a machine readable form. Not only that, this general process can be repeated for a large number of slightly differing PDFs with a relatively high low error rate. In cases where errors do occur, a second layer can be used to run the more challenging PDFs through AWS Textract SDK. We will show how this is done in our next post.



